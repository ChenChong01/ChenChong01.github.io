<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Blog</title>
      <link href="/2022/06/26/blog/"/>
      <url>/2022/06/26/blog/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a><strong>hexo s</strong></h2><pre class="line-numbers language-none"><code class="language-none">hexo s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p><ul><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><h2 id="git-config-–global-–unset-http-proxy"><a href="#git-config-–global-–unset-http-proxy" class="headerlink" title="git config –global –unset http.proxy"></a><strong>git config –global –unset http.proxy</strong></h2><pre class="line-numbers language-none"><code class="language-none">git config --global --unset http.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取消代理权限，搭梯子后若不取消代理权限，容易出问题</p><h2 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h2><pre class="line-numbers language-none"><code class="language-none">hexo new "学习笔记  六"1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p><ul><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li></ul><h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h2><pre class="line-numbers language-none"><code class="language-none">hexo d1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自动生成网站静态文件，并部署到设定的仓库。</p><ul><li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li></ul><h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h2><pre class="line-numbers language-none"><code class="language-none">hexo clean1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清除缓存文件 db.json 和已生成的静态文件 public 。</p><ul><li>网站显示异常时可以执行这条命令试试。</li></ul><h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h2><pre class="line-numbers language-none"><code class="language-none">hexo g1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成网站静态文件到默认设置的 public 文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><h2 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h2><pre class="line-numbers language-none"><code class="language-none">hexo new page aboutme1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li><p>git init 初始化一个仓库 ，会将该目录下所有文件交给git管理</p></li><li><p>git status 查看当前版本管理状态</p></li><li><p>git add 文件1 文件2… 把有变化的文件(新增的、修改的、删除的) 添加到git暂存区里</p><blockquote><p>git add . 将所有改变的文件统一 加入到暂存区里</p></blockquote></li><li><p>git rm –cached 文件1 文件2 把暂存区中的文件从暂存区移除</p></li><li><p>git commit -m ‘提交描述’</p></li><li><p>git restore 文件1 文件 2 … 放弃文件的改变</p></li><li><p>git log 查看提交历史</p></li><li><p>git reflog 查看命令历史</p></li><li><p>git reset –hard commitid 恢复到指定版本</p></li><li><p>```csharp<br>git remote add origin <a href="https://gitee.com/nieps/javademo.git">https://gitee.com/nieps/javademo.git</a>   将本地仓库与远程仓库建立联系</p><pre class="line-numbers language-none"><code class="language-none">- git push -u origin master 将本地代码推送到远程 首次推送- git push -f origin master 强制推送本地代码到远程- git remote 查看远程分支的名称- git remote -v 查看远程分支的名称及远程仓库的地址- git remote rm 远程分支名称 删除要本地仓库与远程仓库的关联关系- git pull niu master 拉取远程服务器代码- git clone 远程分支地址 将远程代码克隆到本地- git 命令 --help 查看命令帮助- git branch 查看当前的分支- git checkout -b 分支的名称 创建并切换到分支上- git switch -c 分支名称 创建并切换到分支上- git branch -d 分支名称 删除分支  &gt; git branch 分支的名称 创建分支  &gt;  &gt; git checkout 分支的名称 切换分支  - git merge 分支名称 将分支中的内容合并到当前分支  - git switch 分支名称 切换到分支上  - git tag 标签名 创建一个标签 默认该标签指向最新的commitid  - git tag 查看所有标签  - git tag 标签名 commitid 给指定的commit打标签  - git tag -d 标签名 删除标签  - git push 远程分支名称 标签名 将指定标签推送到远程  - git push 远程分支名称 --tags 将所有标签推送到远程    &gt; 删除远程标签：    &gt;    &gt; 1. 先删除本地 git tag -d 标签名    &gt; 2. 删除远程 git push 远程分支名称 :/refs/tags/标签名  - git push origin(远程分支名称) 本地分支：远程分支 将本地的分支推送到远程分支    &gt; git branch -d 删除本地分支    &gt;    &gt; git push origin(远程分支名称) --delete 远程仓库分支名称```bashgit initgit add .git commit -m "****" git remote add origin ***git push -u origin mastergit pull --rebase origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux和vim</title>
      <link href="/2022/06/25/tmux-he-vim/"/>
      <url>/2022/06/25/tmux-he-vim/</url>
      
        <content type="html"><![CDATA[<p>aaaaaaaaaaaaaaaaaaaaaaaaaa</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用文件管理命令</title>
      <link href="/2022/06/25/chang-yong-wen-jian-guan-li-ming-ling/"/>
      <url>/2022/06/25/chang-yong-wen-jian-guan-li-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>aaaaaaaaaaaaa</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2022/06/23/shu-zu-qu-chong/"/>
      <url>/2022/06/23/shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<p>数组去重</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;set&gt;using namespace std;int main() {    //set去重方法, 原数组可以无序    int nums1[] = {1, 3, 1, 2, 2, 3, 4, 5, 5, 6};    int len = sizeof(nums1) / sizeof(int); //计算出元素个数    vector&lt;int&gt; vec(nums1, nums1 + len); //将数组转换成vector数组    set&lt;int&gt; s(vec.begin(), vec.end());    vec.assign(s.begin(), s.end()); //将s中的数据复制到vec    for(int x : vec) {        cout &lt;&lt; x &lt;&lt; " ";    }    cout &lt;&lt; endl;    //unique的vector去重方法， 原数组必须有序，若无序则需要排序    vector&lt;int&gt; nums2 = {10, 10, 11, 11, 12, 13, 14, 14, 15, 16};    sort(nums2.begin(), nums2.end());    //vector&lt;int&gt;::iterator n = unique(nums2.begin(), nums2.end());    //nums2.erase(n, nums2.end());    nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end()); //等同于上面两行    for(int y : nums2) {        cout &lt;&lt; y &lt;&lt; " ";    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配</title>
      <link href="/2022/05/05/zi-fu-chuan-pi-pei/"/>
      <url>/2022/05/05/zi-fu-chuan-pi-pei/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>字符串又称模式匹配（pattern matching）。该问题可以概括为：给定字符串<code>S</code>和<code>T</code>，在母串<code>S</code>中寻找子串<code>T</code>。子串<code>T</code>称为模式串 (pattern)。</p><h3 id="一、暴力匹配"><a href="#一、暴力匹配" class="headerlink" title="一、暴力匹配"></a>一、暴力匹配</h3><p>暴力算法（Brute Force Algorithm）又叫朴素字符串匹配算法（Naive String Matching Algorithm）。<br>该算法的基本思路就是将字符一个一个地进行比较：</p><p>​        如果S和T两个字符串的第一个字符相同就比较第二个字符,如果相同就一直继续；<br>​        如果其中有某一个字符不同，则将T字符串向后移一位，将S字符串的第二个字符与T的字符串的第一个字符重新开始比较。<br>​        循环往复，一直到结束。</p><p>1.<img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png" alt="img"></p><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p><p>2.<img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png" alt="img"></p><p>因为B与A不匹配，搜索词再往后移。</p><p>3.<img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png" alt="img"></p><p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p><p>4.<img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png" alt="img"></p><p>接着比较字符串和搜索词的下一个字符，还是相同。</p><p>5.<img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p><p>6.<img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png" alt="img"></p><p>重复上述操作，直至匹配。</p><p><strong>代码演示01：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string S, T;int main() {cin &gt;&gt; S &gt;&gt; T;int i = 0, j = 0;while(i &lt; S.size() &amp;&amp; j &lt; T.size()) {if(S[i] == T[j]) {i ++;j ++;} else {i = i - j + 1; //主串回溯到上次回溯位置的下一个位置j = 0; //模式串回溯到第一个位置}}if(j = T.size() - 1) cout &lt;&lt; "yes" &lt;&lt; endl; //模式串匹配到最后一个位置else cout &lt;&lt; "no" &lt;&lt; endl;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码演示02：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*************************************************************************      &gt; File Name: KMP01.cpp      &gt; Author: 小学生陈冲同学      &gt; Mail: 2092518741@qq.com      &gt; Created Time: Mon May  2 20:14:39 2022 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int N = 1010;char text[N], pattern[N];int brute_force(char *s, char *t) {    int len1 = strlen(s);    int len2 = strlen(t);    for(int i = 0; i &lt; len1 - len2 + 1; i ++ ) {        int j = 0;        for(; t[j]; j ++ ) {            if(t[j] == s[i + j]) continue;            break;        }        if(!t[j]) return i;    }    return -1;}int main() {    scanf("%s%s", text, pattern);    cout &lt;&lt; "brute_force(" &lt;&lt; text &lt;&lt; ", " &lt;&lt; pattern &lt;&lt; ") = " &lt;&lt; brute_force(text, pattern) &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、KMP算法"><a href="#二、KMP算法" class="headerlink" title="二、KMP算法"></a>二、KMP算法</h3><p><strong>kmp算法简介</strong></p><p>Knuth-Morris-Pratt算法（简称KMP）是最常用的字符串匹配算法之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/c5d0a57b50ba31c2.png"></p><p><strong>通过暴力匹配找出KMP算法规律</strong></p><p>首先，母串”aecaeaecaed”的第一个字符与模式串”aecaed”的第一个字符，进行比较。因为a与a匹配，所以母串指针与模式串指针同时后移</p><p>时间复杂度O（n）</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/4a726a79312d048e.png"></p><p>指针后移后重复操作。匹配到图中位置，发现并不匹配</p><img src="https://s3.bmp.ovh/imgs/2022/05/05/0db3b70f1556af7c.png"><p>模式串后移一位，母串指针回到“e”位置，模式串指针回到开头“a”的位置。（母串指针前移是造成暴力匹配效率低的重要因素之一）</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/2383f16506579461.png"></p><p>重复以上操作匹配成功</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/129314f07ccb1fbb.png"></p><p>![Image 345](E:\截图保存\Image 345.png)</p><p>接下来引入暴力优化为kmp算法</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/8637a036a6b3ca8b.png"></p><p>模式串前移</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/00bff45a55ebcc7c.png"></p><p>模式串自身之间的关系（前缀与后缀）</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/4f60bb5108ffcd70.png"></p><p>next数组</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/33d16e04b122be03.png"></p><p>课堂练习求next数组</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/03d00458d2aef83a.png"></p><p>答案</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/d9df00143871de77.png"></p><p>模拟KMP算法</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/36801230461c988c.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/cffc99f860d7d452.png"></p><p>kmp算法的关键就是母串指针从始至终并未前移</p><p><strong>代码实现：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*************************************************************************      &gt; File Name: KMP01.cpp      &gt; Author: 小学生陈冲同学      &gt; Mail: 2092518741@qq.com      &gt; Created Time: Mon May  2 20:14:39 2022 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int N = 1010;char text[N], pattern[N];int kmp(char *s, char *t) {    int len1 = strlen(s);    int len2 = strlen(t);    int *next =  (int *)malloc(sizeof(int) * len2);    next[0] = -1;    for(int i = 1, j = -1; i &lt; len2; i++) { //初始化next数组        while(j != -1 &amp;&amp; t[j + 1] != t[i]) j = next[j];        if(t[j + 1] == t[i]) j += 1;        next[i] = j;    }    for(int i = 0, j = -1; s[i]; i++) {        while(j != -1 &amp;&amp; t[j + 1] != s[i]) j = next[j];        if(t[j + 1] == s[i]) j += 1;        if(t[j + 1] == 0) return i - len2 + 1;    }    free(next);    return -1;}int main() {    scanf("%s%s", text, pattern);    cout &lt;&lt; "kmp(" &lt;&lt; text &lt;&lt; ", " &lt;&lt; pattern &lt;&lt; ") = " &lt;&lt; kmp(text, pattern) &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、Sunday算法"><a href="#三、Sunday算法" class="headerlink" title="三、Sunday算法"></a>三、Sunday算法</h3><p><strong>sunday算法简介</strong></p><p>​    Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：只不过Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。</p><p>​    如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；<br>​    否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始，即最后出现的位置) = 模式串中该字符最右出现的位置到尾部的距离 + 1。<br>下面举个例子说明下Sunday算法。假定现在要在主串”substring searching”中查找模式串”search”。</p><p>时间复杂度最好为O（m / n）,适合查找模式串是否在母串出现过</p><p>第一次出现不匹配</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/91eee5220f62505a.png"></p><p>匹配失败，关注主串中参加匹配的最末位字符的下一位字符</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/d5e5c2d1c1f78333.png"></p><p>在模式串查找是否有这个字符</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/0be84cc61a856484.png"></p><p>若模式串中出现此字符，模式串右移，从字符串首位重新开始匹配</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/7fab9834f622f81a.png"></p><p>如果仍有匹配失败的情况，循环上述过程，直至匹配成功或模式串无法再右移</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/05/a4ed804d584bded6.png"></p><p><strong>代码实现</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*************************************************************************      &gt; File Name: KMP01.cpp      &gt; Author: 小学生陈冲同学      &gt; Mail: 2092518741@qq.com      &gt; Created Time: Mon May  2 20:14:39 2022 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;stack&gt;using namespace std;const int N = 1010;char text[N], pattern[N];int sunday(char *s, char *t) {    //初始化ind数组，ind数组存储的是字符存储在模式串的倒数第几位    int ind[128] = {0};    int len1 = strlen(s);    int len2 = strlen(t);    for(int i = 0; i &lt; 128; i++) ind[i] = len2 + 1; //默认倒数len + 1位    for(int i = 0; t[i]; i++) ind[t[i]] = len2 - i; //从头遍历，两个字符若相同，则会覆盖，最终值为最后出现的位置    //遍历    for(int i = 0; i &lt; len1 - len2 + 1; ) {        int flag = 1;        for(int j = 0; j &lt; len2; j++) {            if(t[j] == s[i + j]) continue;            i += ind[s[i + len2]];            flag = 0;            break;        }        if(flag) return i;    }    return -1;}int main() {    scanf("%s%s", text, pattern);    cout &lt;&lt; "sunday(" &lt;&lt; text &lt;&lt; ", " &lt;&lt; pattern &lt;&lt; ") = " &lt;&lt; sunday(text, pattern) &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim常用命令</title>
      <link href="/2022/05/05/vim-chang-yong-ming-ling/"/>
      <url>/2022/05/05/vim-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>　　vim是linux最常用的编辑器，必须要熟练掌握使用办法，方便以后快速修改配置文件。如果想学习linux，vim编辑器是必须会用的工具。</p><p>　　vim有3种常用模式：一般模式、编辑模式、命令模式。</p><h4 id="2、一般模式"><a href="#2、一般模式" class="headerlink" title="2、一般模式"></a>2、一般模式</h4><h5 id="（1）光标："><a href="#（1）光标：" class="headerlink" title="（1）光标："></a>（1）光标：</h5><p>　　上下左右:kjhl 也可以使用方向键</p><p>　　n+上下左右:n为数字，向上下左右移动n个字符</p><p>　　[ctrl]+f:屏幕向下滚动一页，同page down</p><p>　　[ctrl]+b:屏幕向上滚动一页，同page up</p><p>　　0或home:光标移动到行首</p><p>　　$或end:光标移动到行尾</p><p>　　G:光标移动到最后一行</p><p>　　gg:同1g，光标移动到第一行行首</p><p>　　ng:光标移动到第n行</p><p>​    　u:恢复前一个操作</p><p>　　[ctrl]+r:重做上一个操作</p><h5 id="（2）查找替换："><a href="#（2）查找替换：" class="headerlink" title="（2）查找替换："></a>（2）查找替换：</h5><p>　　/word:向下查找关键词，使用n或N向上或向下查找关键词</p><p>　　?word:向上查找关键词word，使用n或N向上或向下查找关键词</p><p>​        ：noh  取消高亮</p><p>　　:n1,n2s/word1/word2/g  :  s/1/2/g 表示将1替换成2，所以前面的意思是在n1到n2之间，将word1替换为word2.例如：51,100s/aaa/bbb/g</p><p>　　:1,$s/word1/word2/g : 全文查找替换将word1替换为word2</p><h5 id="（3）删除："><a href="#（3）删除：" class="headerlink" title="（3）删除："></a>（3）删除：</h5><p>　　x:向后删除</p><p>　　X:向前删除</p><p>　　nx:向后删除n个字符</p><p>　　dd:删除当前行　</p><p>　　ndd:向下删除n行</p><p>　　d1G:删除当前位置到第一行</p><h5 id="（4）复制，粘贴"><a href="#（4）复制，粘贴" class="headerlink" title="（4）复制，粘贴"></a>（4）复制，粘贴</h5><p>​        yy 复制当前行</p><p>​        v   从光标当前位置开始，光标所经过的地方会被选中，再按一下v结束。 </p><p>​        V   从光标当前行开始，光标经过的行都会被选中，再按一下Ｖ结束。 </p><p>​        ggVG 选中全部的文本， 其中gg为跳到行首，V选中整行，G末尾</p><p>​        选中后就可以用编辑命令对其进行编辑，如 </p><p>​        y  复制 （默认是复制到”寄存器） </p><p>​        p  粘贴 （默认从”寄存器取出内容粘贴） </p><p>​        “+y   复制到系统剪贴板(也就是vim的+寄存器） </p><p>​        “+p  从系统剪贴板粘贴 </p><h4 id="3、一般模式切换到编辑模式"><a href="#3、一般模式切换到编辑模式" class="headerlink" title="3、一般模式切换到编辑模式"></a>3、一般模式切换到编辑模式</h4><p>　　i:进入插入模式，在光标前插入  I是在第一个非空格符处插入</p><p>　　a:进入插入模式，在光标下一个字符插入 A是在所在行最后一个字符插入</p><p>　　o:进入插入模式，在下面一行插入  O是在上面一行出入</p><p>　　r:进入替换模式，类似于insert键</p><h4 id="4、一般模式到命令模式"><a href="#4、一般模式到命令模式" class="headerlink" title="4、一般模式到命令模式"></a>4、一般模式到命令模式</h4><p>　　:w 保存</p><p>　　:w! 强制保存</p><p>　　:q 退出</p><p>　　:q! 强制退出</p><p>　　:wq :x 保存并退出</p><p>　　ZZ 保存并退出</p><p>　　:set number 显示行号</p><p>　　:set nonu 取消显示行号</p><p>　　</p><h4 id="5、多文件编辑"><a href="#5、多文件编辑" class="headerlink" title="5、多文件编辑"></a>5、多文件编辑</h4><p>　　vim file1 file2可以同时打开两个文件</p><p>　　:n 编辑下一个文件</p><p>　　:N 编辑上一个文件</p><p>　　:file 列出这个vim打开的所有文件 </p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维费用的背包问题</title>
      <link href="/2022/04/25/er-wei-fei-yong-de-bei-bao-wen-ti/"/>
      <url>/2022/04/25/er-wei-fei-yong-de-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>二维费用的背包问题与01 背包很像，只不过实在 01 背包的基础上加上了一个条件限制。</p><p>01 背包的动态转移方程是</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i][j] = f[i - 1][j] //不含if[i][j] = max(f[i][j], f[i - 1][j - v] + w); //含if[j] = max(f[j], f[j - v] + w) //优化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么这个多了个条件，那么可以再开一维，变成三维</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i][j][k] = f[i - 1][j][k] //不含if[i][j][k] = max(f[i][j][k], f[i - 1][j - v1][k - v2] + w); //含if[j][k] = max(f[j][k, f[j - v1][k - v2] + w) //优化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>样例1：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">题目链接 ： https://www.acwing.com/problem/content/8/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, V, M;int f[N][N];int main() {    cin &gt;&gt; n &gt;&gt; V &gt;&gt; M;        for(int i = 0; i &lt; n; i++) {        int v, m, w;        cin &gt;&gt; v &gt;&gt; m &gt;&gt; w;        for (int j = V; j &gt;= v; j -- )            for (int k = M; k &gt;= m; k -- )                f[j][k] = max(f[j][k], f[j - v][k - m] + w);    }    cout &lt;&lt; f[V][M] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>样例2：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">题目链接 ： https://www.acwing.com/problem/content/1024/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m, x;int f[N][N];int main() {    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;        for(int i = 0; i &lt; x; i++) {        int v1, v2;        cin &gt;&gt; v1 &gt;&gt; v2;        for (int j = n; j &gt;= v1; j -- )            for (int k = m - 1; k &gt;= v2; k -- )                f[j][k] = max(f[j][k], f[j - v1][k - v2] + 1);    }        cout &lt;&lt; f[n][m - 1] &lt;&lt; " ";    int k = m - 1;    while (k &gt; 0 &amp;&amp; f[n][k - 1] == f[n][m - 1]) k -- ;    cout &lt;&lt; m - k &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 背包九讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题1.0</title>
      <link href="/2022/04/22/bei-bao-wen-ti-1-0/"/>
      <url>/2022/04/22/bei-bao-wen-ti-1-0/</url>
      
        <content type="html"><![CDATA[<p>0-1背包、完全背包、多重背包小结</p><h3 id="1、0-1背包"><a href="#1、0-1背包" class="headerlink" title="1、0~1背包"></a>1、0~1背包</h3><p>0~1背包，每种物品最多只能用一次，且只有两种状态：选与不选</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">集合f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>含义：从前i件物品中选择，总体积（或价值）不超过j<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">题目链接 ：https://www.acwing.com/problem/content/2/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>二维</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m; //n件物品， 容量为mint v[N], w[N]; //体积，价值int f[N][N]; //状态int main() {    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];        //f[0][0] = 0;    for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt;= m; j++) {            f[i][j] = f[i - 1][j]; //不含i            if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); //含i        }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化：一维</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt;= m; j++) {            f[i][j] = f[i - 1][j]; //不含i            if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);        }//直接删去一维for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt;= m; j++) {            f[j] = f[j]; //不含i            if(j &gt;= v[i]) f[j] = max(f[j], f[j - v[i]] + w[i]);            //因为j - v[i] &lt; j, 所以在遍历f[j]之前就已经遍历过f[j - v[i]], f[j - v[i]]相当于f[i][j - v[i]]，而我们想要的是f[i - 1][j - v[i]],故如此优化并不正确        }//正确优化for(int i = 1; i &lt;= n; i++)        for(int j = m; j &gt;= v[i]; j--) {            f[j] = max(f[j], f[j - v[i]] + w[i]); //含i            //j从大到小遍历，j &gt; j - v[i], 所以遍历f[j]时f[j - v[i]]并没有被遍历，仍相当于f[i - 1][j - v[i]]        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m; //n件物品， 容量为mint v[N], w[N]; //体积，价值int f[N]; //状态int main() {    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];           for(int i = 1; i &lt;= n; i++)        for(int j = m; j &gt;= v[i]; j--) {            f[j] = max(f[j], f[j - v[i]] + w[i]); //含i        }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、完全背包"><a href="#2、完全背包" class="headerlink" title="2、完全背包"></a>2、完全背包</h3><p>完全背包问题，每件物品可以无限选择</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">集合f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>含义：从前i件物品中选择，总体积（或价值）不超过j<span class="token punctuation">(</span>注意：每件物品可无限制选择<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">题目链接 ： https://www.acwing.com/problem/content/3/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>二维</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main() {    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt;= m; j++)             for(int k = 0; k * v[i] &lt;= j; k++)                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);        cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化二维</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main() {    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt;= m; j++) {            f[i][j] = f[i - 1][j];            if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);        }        cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化一维</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main() {    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i = 1; i &lt;= n; i++)        for(int j = v[i]; j &lt;= m; j++) {            f[j] = max(f[j], f[j - v[i]] + w[i]);        }        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、多重背包问题"><a href="#3、多重背包问题" class="headerlink" title="3、多重背包问题"></a>3、多重背包问题</h3><p>多重背包问题，可以理解成完全背包的进阶版，每种物品不再像完全背包问题一样可无限选择，而是最多选择s（s是有限的）件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">集合f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>含义：从前i件物品中选择，总体积（或价值）不超过j<span class="token punctuation">(</span>注意：每件物品最多选择s件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>暴力</strong></p><pre class="line-numbers language-none"><code class="language-none">题目链接 ：https://www.acwing.com/problem/content/4/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int v[N], w[N], s[N];int f[N][N];int main() {    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];        for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt;= m; j++)             for(int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);                    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">题目链接 ： https://www.acwing.com/problem/content/5/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 25000, M = 2010;int n, m;int v[N], w[N];int f[N];int main() {    cin &gt;&gt; n &gt;&gt; m;        int cnt = 0;    for(int i = 1; i &lt;= n; i++) {        int a, b, s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        int k = 1;        while(k &lt;= s) {            cnt ++;            v[cnt] = a * k;            w[cnt] = b * k;            s -= k;            k *= 2;        }         if(s &gt; 0) {            cnt ++;            v[cnt] = a * s;            w[cnt] = b * s;        }    }        n = cnt;        for(int i = 1; i &lt;= n; i++)        for(int j = m; j &gt;= v[i]; j--)            f[j] = max(f[j], f[j - v[i]] + w[i]);                    cout &lt;&lt; f[m] &lt;&lt; endl;        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 背包九讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL小结</title>
      <link href="/2022/04/21/stl-xiao-jie/"/>
      <url>/2022/04/21/stl-xiao-jie/</url>
      
        <content type="html"><![CDATA[<p>STL(standard template libaray-标准模板库)：<strong>是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包括数据结构与算法的软件框架</strong></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*vector  变长数组，倍增的思想size() //返回个数empty() //返回是否为空clear() //清空string 字符串queue, priority_queue //队列， 优先队列（堆）stack //栈deque //双端队列set, map, multisrt, mulimap //基于平衡二叉树（红黑树）， 动态维护有序序列unordered_set, unordered_map, unordered_multiset, unordered_multimap //哈希表bitset // 压位， 位运算，位存储，状态压缩*/vector // 变长数组，倍增的思想    size()  //返回元素个数    empty()  //返回是否为空    clear()  //清空    front()//back()    push_back()//pop_back()    begin()/end()    []    支持比较运算，按字典序pair&lt;int, int&gt;    first, 第一个元素    second, 第二个元素    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串    size()/length()  返回字符串长度    empty()    clear()    substr(起始下标，(子串长度))  返回子串    c_str()  返回字符串所在字符数组的起始地址queue, 队列    size()    empty()    push()  向队尾插入一个元素    front()  返回队头元素    back()  返回队尾元素    pop()  弹出队头元素priority_queue, 优先队列，默认是大根堆    size()    empty()    push()  插入一个元素    top()  返回堆顶元素    pop()  弹出堆顶元素    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈    size()    empty()    push()  向栈顶插入一个元素    top()  返回栈顶元素    pop()  弹出栈顶元素deque, 双端队列    size()    empty()    clear()    front()/back()    push_back()/pop_back()    push_front()/pop_front()    begin()/end()    []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列    size()    empty()    clear()    begin()/end()    ++, -- 返回前驱和后继，时间复杂度 O(logn)    set/multiset        insert()  插入一个数        find()  查找一个数        count()  返回某一个数的个数        erase()            (1) 输入是一个数x，删除所有x   O(k + logn)            (2) 输入一个迭代器，删除这个迭代器        lower_bound()/upper_bound()            lower_bound(x)  返回大于等于x的最小的数的迭代器            upper_bound(x)  返回大于x的最小的数的迭代器    map/multimap        insert()  插入的数是一个pair        erase()  输入的参数是pair或者迭代器        find()        []  注意multimap不支持此操作。 时间复杂度是 O(logn)        lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表    和上面类似，增删改查的时间复杂度是 O(1)    不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位    bitset&lt;10000&gt; s;    ~, &amp;, |, ^    &gt;&gt;, &lt;&lt;    ==, !=    []    count()  //返回有多少个1    any()  //判断是否至少有一个1    none()  //判断是否全为0    set()  //把所有位置成1    set(k, v)  //将第k位变成v    reset()  //把所有位变成0    flip()  //等价于~    flip(k) //把第k位取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*************************************************************************        &gt; File Name: STL.cpp      &gt; Author: ChenChong      &gt; Mail: 2092518741@qq.com      &gt; Created Time: Thu Oct 28 18:39:20 2021 ************************************************************************//** vector  变长数组，倍增的思想*   size() //返回个数*   empty() //返回是否为空*   clear() //清空*   front() / back() //返回首个元素/末尾元素*   push_back() / pop_back() //尾部插入 / 删除*   begin() / end() //第一个数/ 最后一个数后面的一个数*   vector 支持随机寻址*   支持比较运算， 按字典序** pair&lt;int, int&gt; //存储二元组*   first 第一个元素*   second 第二个元素*   支持比较运算， 以first为第一关键字， 以second为第二关键字 （字典序）** string 字符串 substr(), c_str()*   size() / length()*   empty()*   clear()** queue,队列*   size()*   empty()*   push() 向队尾插入一个元素*   front() 返回队头元素*   back() 返回队尾元素*   pop() 弹出队头元素** priority_queue 优先队列（堆） 默认是大根堆*   //变为小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;*   push() 插入一个元素*   top() 返回堆顶元素*   pop() 弹出堆顶元素*** stack //栈*   size()*   empty()*   push() 向栈顶插入一个元素*   top() 返回栈顶元素*   pop() 弹出栈顶元素** deque //双端队列*   size()*   empty()*   clear()*   front()*   back()*   push_back() / pop_back()*   push_front() / pop_front()*   支持随机寻址[]*   begin() / end()***set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列    size()    empty()    clear()    begin()/end()    ++, -- 返回前驱和后继，时间复杂度 O(logn)    set/multiset        insert()  插入一个数        find()  查找一个数        count()  返回某一个数的个数        erase()            (1) 输入是一个数x，删除所有x   O(k + logn)            (2) 输入一个迭代器，删除这个迭代器        lower_bound()/upper_bound()            lower_bound(x)  返回大于等于x的最小的数的迭代器            upper_bound(x)  返回大于x的最小的数的迭代器    map/multimap        insert()  插入的数是一个pair        erase()  输入的参数是pair或者迭代器        find()        []  注意multimap不支持此操作。 时间复杂度是 O(logn)        lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表    和上面类似，增删改查的时间复杂度是 O(1)    不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位    bitset&lt;10000&gt; s;    ~, &amp;, |, ^    &gt;&gt;, &lt;&lt;    ==, !=    []    count()  //返回有多少个1    any()  //判断是否至少有一个1    none()  //判断是否全为0    set()  //把所有位置成1    set(k, v)  //将第k位变成v    reset()  //把所有位变成0    flip()  //等价于~    flip(k) //把第k位取反**/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;int main() {//vector用法    cout &lt;&lt; "vector的用法： " &lt;&lt; endl;    vector&lt;int&gt; a;    vector&lt;int&gt; b(10);    vector&lt;int&gt; c(10, 3);    vector&lt;int&gt; d[10];    for(auto x : c) cout &lt;&lt; x &lt;&lt; " ";    cout &lt;&lt; endl;    a.size();// 长度    a.empty(); //判空    //时间复杂的O(1);    cout &lt;&lt; c.size() &lt;&lt; endl;    cout &lt;&lt; a.empty() &lt;&lt; endl; //空返回1；    cout &lt;&lt; c.empty() &lt;&lt; endl;    c.clear() ;    cout &lt;&lt; c.empty() &lt;&lt; endl;    cout &lt;&lt; "_________________________________________" &lt;&lt; endl;    for(int i = 0; i &lt; 10; i++) a.push_back(i);    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; " ";    cout &lt;&lt; endl;    //迭代器    for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; " ";    cout &lt;&lt; endl;    for(auto x : a) cout &lt;&lt; x &lt;&lt; " ";    cout &lt;&lt; endl;    cout &lt;&lt; "_________________________________________" &lt;&lt; endl;    cout &lt;&lt; a.front() &lt;&lt; " " &lt;&lt; a.back() &lt;&lt; endl;    a.push_back(10);    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; " ";    cout &lt;&lt; endl;    a.pop_back();    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; " ";    cout &lt;&lt; endl;    vector&lt;int&gt; a1(4, 3);    vector&lt;int&gt; b1(3, 4);    if(a1 &lt; b1) puts("a1 &lt; b1");    cout &lt;&lt; "_________________________________________" &lt;&lt; endl;    cout &lt;&lt; "pair的用法： " &lt;&lt; endl;    pair&lt;int, string&gt;p;    pair&lt;int, pair&lt;int, int&gt;&gt;p2;    p = make_pair(10, "niubi");    p = {20, "abc"};    cout &lt;&lt; "string的用法： " &lt;&lt; endl;    string str = "nibbi";    str += "/do";    str += "/dd";    cout &lt;&lt; str &lt;&lt; endl;    cout &lt;&lt; str.substr(1) &lt;&lt; endl;    cout &lt;&lt; str.substr(1, 3) &lt;&lt; endl;    printf("%s\n", str.c_str());    set&lt;int&gt; S; //不能有重复元素    multiset&lt;int&gt; MS; //可以有重复元素    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
